{
  "tasks": [
    {
      "id": 1,
      "title": "Setup Next.js Project with TypeScript and Authentication",
      "description": "Initialize the Next.js project with TypeScript, configure Clerk authentication, and set up the basic project structure.",
      "details": "1. Create a new Next.js project with TypeScript:\n```bash\nnpx create-next-app@latest tldrSEC --typescript\ncd tldrSEC\n```\n2. Install and configure Clerk for authentication:\n```bash\nnpm install @clerk/nextjs\n```\n3. Set up environment variables in .env.local:\n```\nNEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=your_publishable_key\nCLERK_SECRET_KEY=your_secret_key\n```\n4. Configure Clerk in middleware.ts:\n```typescript\nimport { authMiddleware } from '@clerk/nextjs';\n\nexport default authMiddleware({\n  publicRoutes: ['/', '/api/webhook/clerk'],\n});\n\nexport const config = {\n  matcher: ['/((?!.*\\\\..*|_next).*)', '/', '/(api|trpc)(.*)'],\n};\n```\n5. Set up OAuth providers (Google, GitHub, Twitter) in Clerk dashboard\n6. Create basic layout components and authentication wrapper\n7. Implement sign-in and sign-up pages",
      "testStrategy": "1. Verify project builds without errors\n2. Test authentication flow with each OAuth provider\n3. Verify protected routes redirect to login\n4. Test user session persistence\n5. Verify environment variables are properly loaded\n6. Ensure authentication state is properly managed in the application",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "Configure PostgreSQL Database with Neon",
      "description": "Set up PostgreSQL database using Neon, create the database schema, and implement data models for users, tickers, and summaries.",
      "details": "1. Create a Neon PostgreSQL database account and project\n2. Set up the database connection string in environment variables:\n```\nDATABASE_URL=postgresql://user:password@host:port/database\n```\n3. Install Prisma ORM:\n```bash\nnpm install prisma @prisma/client\nnpx prisma init\n```\n4. Define the database schema in schema.prisma:\n```prisma\nmodel User {\n  id            String    @id @default(uuid())\n  email         String    @unique\n  name          String?\n  authProvider  String\n  authProviderId String\n  createdAt     DateTime  @default(now())\n  preferences   Json?     // Store notification and theme preferences\n  tickers       Ticker[]\n}\n\nmodel Ticker {\n  id          String    @id @default(uuid())\n  symbol      String\n  companyName String\n  userId      String\n  addedAt     DateTime  @default(now())\n  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)\n  summaries   Summary[]\n  @@unique([userId, symbol])\n}\n\nmodel Summary {\n  id          String    @id @default(uuid())\n  tickerId    String\n  filingType  String    // \"10-K\", \"10-Q\", \"8-K\", \"Form4\"\n  filingDate  DateTime\n  filingUrl   String\n  summaryText String    @db.Text\n  summaryJSON Json?\n  createdAt   DateTime  @default(now())\n  sentToUser  Boolean   @default(false)\n  ticker      Ticker    @relation(fields: [tickerId], references: [id], onDelete: Cascade)\n}\n```\n5. Generate Prisma client and run initial migration:\n```bash\nnpx prisma migrate dev --name init\n```\n6. Create database utility functions in lib/db.ts for common operations",
      "testStrategy": "1. Verify database connection works\n2. Test schema migration success\n3. Create test records for each model and verify CRUD operations\n4. Test relationships between models\n5. Verify unique constraints work as expected\n6. Test error handling for database operations",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Neon Account Setup and Database Provisioning",
          "description": "Create a Neon account, set up a PostgreSQL database project, and obtain connection credentials.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 2
        },
        {
          "id": 2,
          "title": "Prisma ORM Installation and Initial Configuration",
          "description": "Install Prisma ORM and set up the initial configuration for the database connection.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 2
        },
        {
          "id": 3,
          "title": "Schema Definition and Model Implementation",
          "description": "Define database schema in schema.prisma for users, tickers, and summaries with proper relationships.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 2
        },
        {
          "id": 4,
          "title": "Database Utility Functions and Connection Testing",
          "description": "Create database utility functions in lib/db.ts and test database connection and CRUD operations.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 2
        }
      ]
    },
    {
      "id": 3,
      "title": "Implement SEC Filing Monitoring Service",
      "description": "Create a service to monitor SEC EDGAR for new filings, match them against user-tracked tickers, and store relevant filings for processing.",
      "details": "1. Create a Vercel cron job by setting up a Next.js API route at app/api/cron/check-filings/route.ts:\n```typescript\nimport { NextResponse } from 'next/server';\nimport { PrismaClient } from '@prisma/client';\nimport axios from 'axios';\nimport * as cheerio from 'cheerio';\n\nconst prisma = new PrismaClient();\n\nexport async function GET() {\n  try {\n    // Fetch all unique tickers being tracked by users\n    const trackedTickers = await prisma.ticker.findMany({\n      select: { symbol: true },\n      distinct: ['symbol']\n    });\n    \n    const tickerSymbols = trackedTickers.map(t => t.symbol);\n    \n    // Fetch recent filings from SEC EDGAR\n    const filings = await fetchRecentFilings();\n    \n    // Filter filings for tracked tickers\n    const relevantFilings = filings.filter(filing => \n      tickerSymbols.includes(filing.ticker)\n    );\n    \n    // Queue relevant filings for processing\n    for (const filing of relevantFilings) {\n      await queueFilingForProcessing(filing);\n    }\n    \n    return NextResponse.json({ success: true, processedCount: relevantFilings.length });\n  } catch (error) {\n    console.error('Error checking filings:', error);\n    return NextResponse.json({ error: 'Failed to check filings' }, { status: 500 });\n  }\n}\n\nasync function fetchRecentFilings() {\n  // Fetch from SEC EDGAR RSS feed or website\n  const response = await axios.get('https://www.sec.gov/cgi-bin/browse-edgar?action=getcurrent&CIK=&type=&company=&dateb=&owner=include&start=0&count=100&output=atom');\n  \n  // Parse the XML/RSS feed\n  const $ = cheerio.load(response.data, { xmlMode: true });\n  \n  const filings = [];\n  $('entry').each((i, entry) => {\n    // Extract filing information\n    const title = $(entry).find('title').text();\n    const link = $(entry).find('link').attr('href');\n    const updated = $(entry).find('updated').text();\n    \n    // Parse ticker from title\n    const tickerMatch = title.match(/\\(([^)]+)\\)/);\n    const ticker = tickerMatch ? tickerMatch[1] : null;\n    \n    // Determine filing type\n    const filingType = determineFilingType(title);\n    \n    if (ticker && filingType) {\n      filings.push({\n        ticker,\n        filingType,\n        title,\n        link,\n        filingDate: new Date(updated)\n      });\n    }\n  });\n  \n  return filings;\n}\n\nfunction determineFilingType(title) {\n  if (title.includes('10-K')) return '10-K';\n  if (title.includes('10-Q')) return '10-Q';\n  if (title.includes('8-K')) return '8-K';\n  if (title.includes('Form 4')) return 'Form4';\n  return null;\n}\n\nasync function queueFilingForProcessing(filing) {\n  // Find all users tracking this ticker\n  const tickers = await prisma.ticker.findMany({\n    where: { symbol: filing.ticker },\n    include: { user: true }\n  });\n  \n  // For each user's ticker, create a summary record\n  for (const ticker of tickers) {\n    await prisma.summary.create({\n      data: {\n        tickerId: ticker.id,\n        filingType: filing.filingType,\n        filingDate: filing.filingDate,\n        filingUrl: filing.link,\n        summaryText: '', // Will be populated after AI processing\n        sentToUser: false\n      }\n    });\n  }\n}\n```\n2. Configure Vercel cron job in vercel.json:\n```json\n{\n  \"crons\": [{\n    \"path\": \"/api/cron/check-filings\",\n    \"schedule\": \"0 * * * *\"\n  }]\n}\n```\n3. Create utility functions for parsing different filing types\n4. Implement error handling and retry logic for SEC API requests\n5. Add logging for monitoring the cron job performance",
      "testStrategy": "1. Test SEC EDGAR API connection and parsing\n2. Verify ticker matching logic works correctly\n3. Test with mock filings data to ensure proper filtering\n4. Verify database entries are created correctly\n5. Test error handling and retry mechanisms\n6. Verify cron job executes on schedule\n7. Test with different filing types to ensure proper detection",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "SEC EDGAR API Integration and Data Fetching",
          "description": "Implement the core functionality to connect to the SEC EDGAR API and retrieve filing data.",
          "dependencies": [],
          "details": "1) Create HTTP client for SEC EDGAR API requests with proper headers and user-agent\n2) Implement rate limiting mechanism to respect SEC's fair access policy (max 10 requests/second)\n3) Build parsers for RSS feeds and index files to extract filing metadata\n4) Create data models for Form types (10-K, 10-Q, 8-K, etc.)\n5) Implement pagination and historical data backfilling\n6) Handle network timeouts and retries with exponential backoff\n7) Test with mock API responses and real API integration tests",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Ticker Matching and Filtering Logic",
          "description": "Develop the logic to match SEC filings with specific company tickers and filter based on form types.",
          "dependencies": [
            1
          ],
          "details": "1) Create a ticker-to-CIK (Central Index Key) mapping database\n2) Implement fuzzy matching for company names when CIK is unavailable\n3) Build configurable filters for form types, date ranges, and filing content\n4) Create logic to handle company name/ticker changes and mergers\n5) Implement text search within filing content for keyword filtering\n6) Test with edge cases like delisted companies, ticker changes, and similar company names\n7) Benchmark performance with large datasets of companies",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Filing Storage and Database Operations",
          "description": "Design and implement the database schema and operations for storing and retrieving SEC filings.",
          "dependencies": [
            1,
            2
          ],
          "details": "1) Design database schema for filings, companies, and metadata\n2) Implement ORM models or SQL queries for CRUD operations\n3) Create indexes for optimized querying by ticker, date, and form type\n4) Implement deduplication logic to prevent duplicate filings\n5) Create data migration scripts for schema updates\n6) Implement archiving strategy for older filings\n7) Test with transaction rollbacks, concurrent writes, and database failover scenarios",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Cron Job Setup and Scheduling",
          "description": "Configure automated scheduling for regular SEC filing checks and updates.",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "1) Implement configurable cron job schedules for different filing types\n2) Create job queuing system for processing large batches of filings\n3) Implement idempotent job execution to prevent duplicate processing\n4) Add logging for job execution status and timing\n5) Create recovery mechanism for failed jobs\n6) Implement distributed locking for multi-instance deployments\n7) Test with clock skew, server restarts, and long-running job scenarios",
          "status": "done"
        },
        {
          "id": 5,
          "title": "Error Handling and Monitoring",
          "description": "Implement comprehensive error handling, logging, and monitoring for the SEC filing service.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "1) Implement structured logging with appropriate log levels\n2) Create alerting for critical failures and API issues\n3) Add metrics collection for API response times, success rates, and filing counts\n4) Implement health check endpoints for service status\n5) Create dashboard for monitoring system performance\n6) Add dead letter queue for failed processing attempts\n7) Test with chaos engineering approaches (API failures, database outages, etc.)",
          "status": "done"
        }
      ]
    },
    {
      "id": 4,
      "title": "Develop Filing Parsing System",
      "description": "Create parsers for different SEC filing formats (HTML, PDF, XBRL) to extract content for AI summarization.",
      "details": "1. Install necessary parsing libraries:\n```bash\nnpm install cheerio pdf-parse xbrl\n```\n2. Create a parsing service in lib/parsers/index.ts:\n```typescript\nimport { parseHTML } from './html-parser';\nimport { parsePDF } from './pdf-parser';\nimport { parseXBRL } from './xbrl-parser';\n\nexport async function parseFilingContent(url: string, filingType: string) {\n  // Determine file type from URL or content\n  const fileType = determineFileType(url);\n  \n  try {\n    switch (fileType) {\n      case 'html':\n        return await parseHTML(url, filingType);\n      case 'pdf':\n        return await parsePDF(url, filingType);\n      case 'xbrl':\n        return await parseXBRL(url, filingType);\n      default:\n        throw new Error(`Unsupported file type: ${fileType}`);\n    }\n  } catch (error) {\n    console.error(`Error parsing ${fileType} content:`, error);\n    throw error;\n  }\n}\n\nfunction determineFileType(url: string): 'html' | 'pdf' | 'xbrl' {\n  if (url.endsWith('.htm') || url.endsWith('.html')) {\n    return 'html';\n  } else if (url.endsWith('.pdf')) {\n    return 'pdf';\n  } else if (url.endsWith('.xml') || url.includes('xbrl')) {\n    return 'xbrl';\n  }\n  \n  // Default to HTML for SEC.gov URLs\n  return 'html';\n}\n```\n3. Implement HTML parser in lib/parsers/html-parser.ts:\n```typescript\nimport axios from 'axios';\nimport * as cheerio from 'cheerio';\n\nexport async function parseHTML(url: string, filingType: string) {\n  const response = await axios.get(url);\n  const $ = cheerio.load(response.data);\n  \n  // Remove unnecessary elements\n  $('script, style, img').remove();\n  \n  let content = '';\n  \n  // Extract content based on filing type\n  if (filingType === '10-K' || filingType === '10-Q') {\n    // Focus on important sections\n    const sections = [\n      'Management\\'s Discussion and Analysis',\n      'Risk Factors',\n      'Financial Statements',\n      'Notes to Financial Statements'\n    ];\n    \n    // Find and extract these sections\n    $('div, section, table').each((i, el) => {\n      const text = $(el).text().trim();\n      if (sections.some(section => text.includes(section))) {\n        content += `\\n\\n${text}`;\n      }\n    });\n  } else if (filingType === '8-K') {\n    // For 8-K, focus on the main content\n    content = $('.formContent, #formDiv').text().trim();\n  } else if (filingType === 'Form4') {\n    // For Form 4, extract transaction tables\n    content = $('.tableFile, table').text().trim();\n  }\n  \n  // If no specific content was found, get all text\n  if (!content) {\n    content = $('body').text().trim();\n  }\n  \n  // Clean up the content\n  content = content\n    .replace(/\\s+/g, ' ')\n    .replace(/\\n\\s*\\n/g, '\\n\\n')\n    .trim();\n  \n  return content;\n}\n```\n4. Implement PDF parser in lib/parsers/pdf-parser.ts\n5. Implement XBRL parser in lib/parsers/xbrl-parser.ts\n6. Create a chunking utility for large documents to handle AI token limits",
      "testStrategy": "1. Test each parser with sample filings of different types\n2. Verify content extraction accuracy for each format\n3. Test with malformed or unusual formatting to ensure robustness\n4. Verify chunking works correctly for large documents\n5. Test error handling for network issues or parsing failures\n6. Benchmark parsing performance for optimization",
      "priority": "medium",
      "dependencies": [
        3
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "HTML Parser Implementation",
          "description": "Develop a robust HTML parser to extract structured data from SEC HTML filings",
          "dependencies": [],
          "details": "Implement using BeautifulSoup4 and lxml for optimal performance. Create functions to extract tables, lists, paragraphs, and headers while preserving document structure. Handle nested elements and malformed HTML. Test with sample 10-K, 10-Q, and 8-K filings from different companies. Include unit tests for each extraction function and integration tests with complete documents. Benchmark performance with large (>10MB) HTML files.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "PDF Parser Implementation",
          "description": "Create a PDF parser capable of extracting text, tables, and metadata from SEC PDF filings",
          "dependencies": [],
          "details": "Use PyPDF2 for basic extraction and pdfplumber for more complex layout analysis. Implement table detection and extraction with Camelot-py. Create functions to handle document structure, page breaks, and footnotes. Develop OCR fallback using Tesseract via pytesseract for scanned documents. Test with various PDF filings including those with complex tables, charts, and scanned pages. Create validation tests comparing extracted content with known values.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "XBRL Parser Implementation",
          "description": "Develop an XBRL parser to extract structured financial data from SEC XBRL filings",
          "dependencies": [],
          "details": "Implement using the python-xbrl library with ElementTree for XML processing. Create functions to extract taxonomy elements, contexts, units, and facts. Build a mapping system for standardized financial metrics across different taxonomies. Handle inline XBRL (iXBRL) with custom extraction logic. Test with XBRL instances from various filers and reporting periods. Validate extracted values against SEC's rendered views. Create comprehensive unit tests for each XBRL component.",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Content Extraction Strategy for Different Filing Types",
          "description": "Develop unified extraction strategies for different SEC filing types (10-K, 10-Q, 8-K, etc.)",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Create a filing type detection system. Implement specific extraction patterns for each major filing type. Develop section identification for standard sections (Risk Factors, MD&A, Financial Statements). Build metadata extraction for filing dates, company info, and reporting periods. Create a unified data model to represent extracted content consistently across formats. Test with a diverse corpus of filings from different years, companies, and industries. Implement validation against known filing structures.",
          "status": "done"
        },
        {
          "id": 5,
          "title": "Document Chunking for Large Filings",
          "description": "Implement efficient chunking strategies for processing large SEC filings",
          "dependencies": [
            4
          ],
          "details": "Develop semantic chunking based on document structure (sections, subsections). Implement size-based chunking with configurable thresholds. Create overlap strategies to maintain context between chunks. Build a reconstruction system to reassemble processed chunks. Optimize memory usage with streaming processing where possible. Test with extremely large filings (>50MB) and measure memory consumption. Validate that chunked processing produces identical results to whole-document processing.",
          "status": "done"
        },
        {
          "id": 6,
          "title": "Parser Error Handling and Recovery",
          "description": "Implement robust error handling and recovery mechanisms for the parsing system",
          "dependencies": [
            1,
            2,
            3,
            4,
            5
          ],
          "details": "Create a comprehensive error classification system. Implement graceful degradation strategies for each parser type. Develop logging and monitoring for parsing failures. Build automatic retry mechanisms with different parsing strategies. Create a validation system to verify extraction quality. Implement partial result handling when complete parsing fails. Test with intentionally malformed documents and real-world problematic filings. Create a feedback loop for continuous improvement based on parsing failures.\n<info added on 2025-05-19T08:57:00.853Z>\nThe error handling and recovery system for the SEC filing parser should include:\n\n1. Create a comprehensive error classification system.\n2. Implement graceful degradation strategies for each parser type.\n3. Develop logging and monitoring for parsing failures.\n4. Build automatic retry mechanisms with different parsing strategies.\n5. Create a validation system to verify extraction quality.\n6. Implement partial result handling when complete parsing fails.\n7. Test with intentionally malformed documents and real-world problematic filings.\n8. Create a feedback loop for continuous improvement based on parsing failures.\n\nImplementation progress:\n- Integrated robust error handling and recovery into the main SEC filing parser system\n- Enhanced parseHTMLFromUrl (html-parser.ts) with withRetry for network fetches and withErrorHandling for structured error handling\n- Implemented classification and logging for network and parsing errors with contextual information\n- Updated parseSECFilingFromUrl (sec-filing-parser.ts) with withErrorHandling and fallback logic\n- Added automatic retry with simplified parsing options (disabling tables/lists/boilerplate removal) when main parsing fails\n- Structured all errors for consistent handling and comprehensive logging\n- Added detailed comments throughout the codebase to guide junior developers on the error handling flow\n- Prepared for end-to-end testing of error handling and recovery in real-world scenarios\n\nNext steps:\n- Execute test script to verify error handling and recovery in production-like environments\n- Analyze logs to identify common failure patterns\n- Refine fallback strategies based on test results\n</info added on 2025-05-19T08:57:00.853Z>\n<info added on 2025-05-19T09:13:54.025Z>\nCreate a comprehensive error classification system. Implement graceful degradation strategies for each parser type. Develop logging and monitoring for parsing failures. Build automatic retry mechanisms with different parsing strategies. Create a validation system to verify extraction quality. Implement partial result handling when complete parsing fails. Test with intentionally malformed documents and real-world problematic filings. Create a feedback loop for continuous improvement based on parsing failures.\n\n<info added on 2025-05-19T08:57:00.853Z>\nThe error handling and recovery system for the SEC filing parser should include:\n\n1. Create a comprehensive error classification system.\n2. Implement graceful degradation strategies for each parser type.\n3. Develop logging and monitoring for parsing failures.\n4. Build automatic retry mechanisms with different parsing strategies.\n5. Create a validation system to verify extraction quality.\n6. Implement partial result handling when complete parsing fails.\n7. Test with intentionally malformed documents and real-world problematic filings.\n8. Create a feedback loop for continuous improvement based on parsing failures.\n\nImplementation progress:\n- Integrated robust error handling and recovery into the main SEC filing parser system\n- Enhanced parseHTMLFromUrl (html-parser.ts) with withRetry for network fetches and withErrorHandling for structured error handling\n- Implemented classification and logging for network and parsing errors with contextual information\n- Updated parseSECFilingFromUrl (sec-filing-parser.ts) with withErrorHandling and fallback logic\n- Added automatic retry with simplified parsing options (disabling tables/lists/boilerplate removal) when main parsing fails\n- Structured all errors for consistent handling and comprehensive logging\n- Added detailed comments throughout the codebase to guide junior developers on the error handling flow\n- Prepared for end-to-end testing of error handling and recovery in real-world scenarios\n\nNext steps:\n- Execute test script to verify error handling and recovery in production-like environments\n- Analyze logs to identify common failure patterns\n- Refine fallback strategies based on test results\n</info added on 2025-05-19T08:57:00.853Z>\n\nThe test-parser-error-handling.ts script has been successfully executed, demonstrating comprehensive error handling and recovery capabilities in the parser system. The test results validate that all required error handling mechanisms are functioning as expected:\n\n1. Retry Mechanism: The withRetry implementation successfully handles network errors with exponential backoff, ensuring resilience against temporary connectivity issues.\n\n2. Fallback Mechanism: The withFallbacks function demonstrates effective graceful degradation by sequentially attempting multiple parsing strategies when the primary approach fails.\n\n3. Parsing Monitoring: The monitoring system successfully captures performance metrics and detects errors during the parsing process, providing valuable insights for troubleshooting.\n\n4. Content Validation: The validator framework correctly identifies structural issues in documents and applies automatic fixes where possible, improving the quality of extracted data.\n\n5. Comprehensive Testing: All 9 test scenarios passed successfully, including expected error cases, confirming the robustness of the error handling system.\n\nThe tests generated a detailed test-results.json file in the test-results directory, which documents both successful and failing test scenarios for future reference and analysis.\n\nThis implementation fully satisfies all the error handling requirements specified for the parser system:\n- Comprehensive error classification (network, parsing, extraction, resource errors)\n- Graceful degradation through fallback mechanisms\n- Detailed logging and monitoring for parsing failures\n- Automatic retry mechanisms with configurable strategies\n- Validation system to verify and improve extraction quality\n- Partial result handling when complete parsing is not possible\n- Thorough testing with both malformed documents and real-world edge cases\n</info added on 2025-05-19T09:13:54.025Z>",
          "status": "done"
        }
      ]
    },
    {
      "id": 5,
      "title": "Integrate Claude AI for Summarization",
      "description": "Implement AI summarization using Anthropic's Claude API with specialized prompts for different filing types.",
      "details": "1. Install Anthropic API client:\n```bash\nnpm install @anthropic-ai/sdk\n```\n2. Set up environment variables:\n```\nANTHROPIC_API_KEY=your_api_key\n```\n3. Create an AI service in lib/ai/summarize.ts:\n```typescript\nimport Anthropic from '@anthropic-ai/sdk';\nimport { parseFilingContent } from '../parsers';\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\nconst anthropic = new Anthropic({\n  apiKey: process.env.ANTHROPIC_API_KEY,\n});\n\n// Prompt templates from the PRD\nconst PROMPT_TEMPLATES = {\n  '10-K': `Analyze this SEC filing document and provide:\n1. Business Impact Analysis:\n   - Identify upside opportunities and risk factors impacting operating margins.\n   - For each:\n      - Headline (max 15 words).\n      - Direct quote as evidence (with section/page reference).\n      - One-sentence margin impact explanation.\n   - Focus on quantifiable, company-specific impacts.`,\n  '10-Q': `Analyze this SEC filing document and provide:\n1. Business Impact Analysis:\n   - Identify upside opportunities and risk factors impacting operating margins.\n   - For each:\n      - Headline (max 15 words).\n      - Direct quote as evidence (with section/page reference).\n      - One-sentence margin impact explanation.\n   - Focus on quantifiable, company-specific impacts.`,\n  '8-K': `Analyze this 8-K SEC filing and provide:\n1. Material Event Analysis:\n   - Identify positive developments, potential concerns, and structural changes.\n   - For each:\n      - Headline (max 15 words).\n      - Direct quote (with item number).\n      - One-sentence business impact explanation.\n   - Focus on material, quantifiable events.`,\n  'Form4': `Analyze this Form 4 SEC filing and provide:\n1. Transaction Analysis:\n   - Summarize insider trading activity (purchases, sales, options).\n   - For each:\n      - Structured data with shares, price, total value, code, ownership.\n   - Include net position changes and context.`\n};\n\n// Output formats from the PRD\nconst OUTPUT_FORMATS = {\n  '10-K': `Output (JSON):\n{\n  \"company\": \"\",\n  \"period\": \"QX YYYY\",\n  \"financials\": [\n    {\"label\": \"Revenue\", \"value\": \"$\", \"growth\": \"\", \"unit\": \"% YoY\"},\n    {\"label\": \"Operating Margin\", \"value\": \"$\", \"growth\": \"\", \"unit\": \"% YoY\"},\n    {\"label\": \"[Key Segment]\", \"value\": \"$\", \"growth\": \"\", \"unit\": \"% YoY\"}\n  ],\n  \"insights\": [\"\", \"\", \"\"],\n  \"risks\": [\"\", \"\", \"\"]\n}`,\n  '10-Q': `Output (JSON):\n{\n  \"company\": \"\",\n  \"period\": \"QX YYYY\",\n  \"financials\": [\n    {\"label\": \"Revenue\", \"value\": \"$\", \"growth\": \"\", \"unit\": \"% YoY\"},\n    {\"label\": \"Operating Margin\", \"value\": \"$\", \"growth\": \"\", \"unit\": \"% YoY\"},\n    {\"label\": \"[Key Segment]\", \"value\": \"$\", \"growth\": \"\", \"unit\": \"% YoY\"}\n  ],\n  \"insights\": [\"\", \"\", \"\"],\n  \"risks\": [\"\", \"\", \"\"]\n}`,\n  '8-K': `Output (JSON):\n{\n  \"company\": \"\",\n  \"reportDate\": \"DD MMM YYYY\",\n  \"eventType\": \"\",\n  \"summary\": \"\",\n  \"positiveDevelopments\": \"\",\n  \"potentialConcerns\": \"\",\n  \"structuralChanges\": \"\",\n  \"additionalNotes\": \"\"\n}`,\n  'Form4': `Output (JSON):\n{\n  \"company\": \"\",\n  \"filingDate\": \"DD MMM YYYY\",\n  \"filerName\": \"\",\n  \"relationship\": \"\",\n  \"ownershipType\": \"\",\n  \"totalValue\": \"$\",\n  \"percentageChange\": \"%\",\n  \"previousStake\": \"\",\n  \"newStake\": \"\",\n  \"summary\": \"\"\n}`\n};\n\nexport async function summarizeFiling(summaryId: string) {\n  // Get the summary record\n  const summary = await prisma.summary.findUnique({\n    where: { id: summaryId },\n    include: { ticker: true }\n  });\n  \n  if (!summary) {\n    throw new Error(`Summary with ID ${summaryId} not found`);\n  }\n  \n  // Parse the filing content\n  const content = await parseFilingContent(summary.filingUrl, summary.filingType);\n  \n  // Get the appropriate prompt template\n  const promptTemplate = PROMPT_TEMPLATES[summary.filingType] || PROMPT_TEMPLATES['10-K'];\n  const outputFormat = OUTPUT_FORMATS[summary.filingType] || OUTPUT_FORMATS['10-K'];\n  \n  // Prepare the full prompt\n  const fullPrompt = `${promptTemplate}\\n\\n${outputFormat}\\n\\nFiling Content:\\n${content}`;\n  \n  try {\n    // Call Claude API\n    const response = await anthropic.messages.create({\n      model: 'claude-2',\n      max_tokens: 1000,\n      messages: [{ role: 'user', content: fullPrompt }],\n    });\n    \n    const summaryText = response.content[0].text;\n    \n    // Try to parse JSON from the response\n    let summaryJSON = null;\n    try {\n      // Extract JSON from the response if it's wrapped in markdown code blocks\n      const jsonMatch = summaryText.match(/```json\\n([\\s\\S]*?)\\n```/) || \n                       summaryText.match(/```\\n([\\s\\S]*?)\\n```/) ||\n                       summaryText.match(/{[\\s\\S]*}/);\n      \n      if (jsonMatch) {\n        summaryJSON = JSON.parse(jsonMatch[0].replace(/```json\\n|```\\n|```/g, ''));\n      } else {\n        summaryJSON = JSON.parse(summaryText);\n      }\n    } catch (error) {\n      console.error('Failed to parse JSON from AI response:', error);\n      // Continue with text summary even if JSON parsing fails\n    }\n    \n    // Update the summary record\n    await prisma.summary.update({\n      where: { id: summaryId },\n      data: {\n        summaryText,\n        summaryJSON\n      }\n    });\n    \n    return { summaryText, summaryJSON };\n  } catch (error) {\n    console.error('Error calling Claude API:', error);\n    throw error;\n  }\n}\n```\n4. Create a processing queue for new filings in app/api/cron/process-filings/route.ts\n5. Add retry logic for API failures\n6. Implement token limit handling for large documents",
      "testStrategy": "1. Test with sample filings of each type\n2. Verify Claude API integration works correctly\n3. Test JSON parsing from AI responses\n4. Verify error handling and retry logic\n5. Test with edge cases (very large documents, unusual formatting)\n6. Verify database updates with summary results\n7. Test prompt effectiveness for each filing type",
      "priority": "high",
      "dependencies": [
        4
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Anthropic API Setup and Client Configuration",
          "description": "Implement the API client for Claude AI, including authentication, request handling, and configuration management.",
          "dependencies": [],
          "details": "1) Create environment variables for API keys and endpoints\n2) Implement a client wrapper class with rate limiting support\n3) Configure request timeouts and connection pooling\n4) Add logging for all API interactions\n5) Create a configuration file for model parameters (temperature, max_tokens)\n6) Test with different Claude models (Claude 3 Opus, Sonnet, Haiku)\n7) Implement token counting to optimize request costs\n<info added on 2025-05-19T09:34:30.649Z>\n1) Create environment variables for API keys and endpoints\n2) Implement a client wrapper class with rate limiting support\n3) Configure request timeouts and connection pooling\n4) Add logging for all API interactions\n5) Create a configuration file for model parameters (temperature, max_tokens)\n6) Test with different Claude models (Claude 3 Opus, Sonnet, Haiku)\n7) Implement token counting to optimize request costs\n\nImplementation completed with the following components:\n- Created configuration system in `lib/ai/config.ts` that manages environment variables with defaults\n- Built robust `ClaudeClient` class in `lib/ai/claude-client.ts` featuring:\n  * API key authentication via environment variables\n  * Rate limiting with Bottleneck library\n  * Retry logic with exponential backoff\n  * Comprehensive error handling and classification\n  * Token usage tracking and cost calculation\n- Implemented token counting utilities in `lib/ai/token-counter.ts`\n- Created detailed documentation in `docs/Claude-Integration.md` covering setup, usage examples, API reference, and best practices\n- Added tests for the client (needs ESM compatibility improvements)\n- Exported both singleton instance and class for custom instantiation\n- Ensured type-safety with TypeScript throughout implementation\n</info added on 2025-05-19T09:34:30.649Z>",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Prompt Engineering for Different Filing Types",
          "description": "Design and optimize prompts for extracting relevant information from various SEC filing types (10-K, 10-Q, 8-K, etc.).",
          "dependencies": [
            1
          ],
          "details": "1) Create a prompt template system with variables for filing-specific instructions\n2) Develop specialized prompts for each filing type with examples\n3) Implement context window management for large documents\n4) Create a test suite with sample filings to evaluate prompt effectiveness\n5) Measure and optimize for accuracy, consistency, and token efficiency\n6) Implement few-shot learning examples in prompts\n7) Design system prompts that enforce output format constraints\n<info added on 2025-05-19T09:46:40.089Z>\n1) Create a prompt template system with variables for filing-specific instructions\n2) Develop specialized prompts for each filing type with examples:\n   - 10-K: Annual report prompts focusing on year-over-year comparisons\n   - 10-Q: Quarterly report prompts emphasizing recent developments\n   - 8-K: Event-based prompts for material changes and announcements\n3) Implement context window management for large documents:\n   - Develop chunking strategies based on document structure\n   - Create section-specific prompts that maintain contextual awareness\n   - Implement intelligent token budget allocation across multiple sections\n   - Design mechanisms to track and maintain coherence between chunks\n4) Create adaptive prompts that adjust based on filing complexity and size:\n   - Implement complexity detection algorithms to modify prompt depth\n   - Design fallback strategies for extremely large documents\n   - Create dynamic few-shot examples based on document characteristics\n5) Add system prompts optimized for security-related analysis:\n   - Risk factor identification and categorization\n   - Material changes in financial position\n   - Management discussion analysis extraction\n   - Regulatory compliance assessment\n6) Create a test suite with sample filings to evaluate prompt effectiveness\n7) Measure and optimize for accuracy, consistency, and token efficiency\n8) Implement few-shot learning examples in prompts\n9) Design system prompts that enforce output format constraints\n</info added on 2025-05-19T09:46:40.089Z>",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Response Parsing and JSON Extraction",
          "description": "Build robust parsers to extract structured data from Claude's responses and convert them into standardized JSON formats.",
          "dependencies": [
            1,
            2
          ],
          "details": "1) Implement regex patterns for extracting JSON from text responses\n2) Create schema validation for each filing type's expected output\n3) Handle malformed JSON with fallback extraction methods\n4) Implement normalization for dates, numbers, and currency values\n5) Create unit tests for each parser with sample responses\n6) Add metrics for parsing success rates and error types\n7) Implement graceful degradation for partially successful extractions\n<info added on 2025-05-19T09:47:46.597Z>\n1) Implement regex patterns for extracting JSON from text responses\n2) Create schema validation for each filing type's expected output\n3) Handle malformed JSON with fallback extraction methods\n4) Implement normalization for dates, numbers, and currency values\n5) Create unit tests for each parser with sample responses\n6) Add metrics for parsing success rates and error types\n7) Implement graceful degradation for partially successful extractions\n\nSTREAMING RESPONSE SUPPORT:\n8) Implement event-based handlers for Claude's streaming API responses\n9) Design buffer management system to efficiently process and store chunks of streaming data\n10) Create adapters that can parse and validate incomplete JSON fragments as they arrive\n11) Implement progressive JSON schema validation that works with partial data\n12) Develop a state management system to track streaming response progress\n13) Build error handling mechanisms specific to stream interruptions, including retry logic\n14) Create TypeScript interfaces for streaming response types and events\n15) Implement UI-ready data transformation for progressive rendering of incoming data\n16) Design resumption protocols for interrupted streams with proper state recovery\n17) Add telemetry for streaming performance metrics (latency, chunk processing time)\n18) Create integration tests simulating various streaming scenarios including slow connections\n</info added on 2025-05-19T09:47:46.597Z>",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Processing Queue Implementation for New Filings",
          "description": "Develop a robust queue system to process incoming filings asynchronously with prioritization and monitoring.",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "1) Implement a message queue using RabbitMQ or AWS SQS\n2) Create worker processes to consume queue messages\n3) Add prioritization based on filing type and importance\n4) Implement dead letter queues for failed processing\n5) Add monitoring dashboards for queue health and throughput\n6) Create auto-scaling logic based on queue depth\n7) Implement idempotent processing to prevent duplicates\n8) Add performance metrics and tracing\n<info added on 2025-05-19T09:48:20.841Z>\n1) Implement a message queue using RabbitMQ or AWS SQS\n2) Create worker processes to consume queue messages\n3) Add prioritization based on filing type and importance\n4) Implement dead letter queues for failed processing\n5) Add monitoring dashboards for queue health and throughput\n6) Create auto-scaling logic based on queue depth\n7) Implement idempotent processing to prevent duplicates\n8) Add performance metrics and tracing\n\nResult Caching and Progress Tracking:\n9) Implement Redis or similar in-memory caching layer to store processing results and summaries\n10) Design efficient cache invalidation mechanisms triggered by filing updates or modifications\n11) Create a progress tracking system using event emitters to broadcast processing status\n12) Develop real-time progress reporting endpoints for UI consumption\n13) Implement incremental cache updates to allow partial results during long-running processes\n14) Add comprehensive metadata tracking for processing times, resource utilization, and system performance\n15) Build cache warming strategies for frequently accessed filings to improve response times\n16) Design a unified progress monitoring dashboard to visualize queue status, processing progress, and cache health\n</info added on 2025-05-19T09:48:20.841Z>\n<info added on 2025-05-19T22:47:46.651Z>\nImplementation Details for SEC Filing Processing Queue:\n\n1. Created processing-filings route in app/api/cron/process-filings/route.ts that:\n   - Identifies unprocessed filings in the database\n   - Creates summary records for each filing\n   - Queues jobs with appropriate prioritization based on filing type\n\n2. Enhanced job processor in app/api/cron/process-jobs/route.ts to:\n   - Handle SUMMARIZE_FILING job types\n   - Call summarization function with appropriate parameters\n   - Update job status on completion or failure\n\n3. Implemented Claude AI summarization service in lib/ai/summarize.ts:\n   - Built custom SummarizationError class for error handling\n   - Added comprehensive logging and monitoring\n   - Created structured workflow (extract → prepare prompt → call Claude → parse response)\n   - Implemented partial results and metrics collection\n\n4. Developed prompt system for different filing types:\n   - Created base PromptTemplate class with token management\n   - Implemented specialized prompts for 10-K, 10-Q, 8-K, and Form 4 filings\n   - Added context window management for large documents\n   - Included structured JSON output format specifications\n\n5. Added filing extractor stub in lib/parsers/filing-extractor.ts:\n   - Created placeholder implementation for future enhancement\n   - Implemented metrics and error handling for content extraction\n\n6. Updated job queue configuration:\n   - Added SUMMARIZE_FILING to JobType type alias\n   - Integrated with existing queue systems\n\nThe implementation provides a complete pipeline for SEC filing processing through Claude AI, from queue to summarization to storage, with a modular architecture supporting future enhancements.\n</info added on 2025-05-19T22:47:46.651Z>",
          "status": "done"
        },
        {
          "id": 5,
          "title": "Error Handling and Retry Mechanisms",
          "description": "Implement comprehensive error handling, retry logic, and failure recovery for the entire processing pipeline.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "1) Categorize errors (API failures, parsing errors, timeout issues)\n2) Implement exponential backoff for retries with jitter\n3) Create circuit breakers for API endpoint protection\n4) Develop alerting system for critical failures\n5) Implement partial success handling for large documents\n6) Create detailed error logs with context for debugging\n7) Design fallback processing paths for different failure modes\n8) Implement automated recovery procedures\n<info added on 2025-05-19T09:48:45.369Z>\n1) Categorize errors (API failures, parsing errors, timeout issues)\n2) Implement exponential backoff for retries with jitter\n3) Create circuit breakers for API endpoint protection\n4) Develop alerting system for critical failures\n5) Implement partial success handling for large documents\n6) Create detailed error logs with context for debugging\n7) Design fallback processing paths for different failure modes\n8) Implement automated recovery procedures\n9) Implement AbortController integration for request cancellation to allow graceful termination of in-flight requests\n10) Design an intelligent model fallback system that automatically tries different Claude models (Claude 3 Opus → Sonnet → Haiku) when primary model fails\n11) Create a cost-based model selection algorithm that balances performance needs against API expenses based on document complexity\n12) Develop dynamic timeout management that adjusts timeouts based on request complexity and document size\n13) Implement graceful cancellation mechanisms that preserve partial results when requests are terminated\n14) Build a model performance monitoring system that tracks success rates, response times, and cost metrics for each Claude model\n15) Design adaptive retry strategies that modify behavior based on specific error types (rate limits, context window exceeded, etc.)\n</info added on 2025-05-19T09:48:45.369Z>",
          "status": "done"
        }
      ]
    },
    {
      "id": 6,
      "title": "Implement Email Notification System",
      "description": "Create an email notification system using Resend to deliver filing summaries to users based on their preferences.",
      "details": "1. Install Resend email service:\n```bash\nnpm install resend\n```\n2. Set up environment variables:\n```\nRESEND_API_KEY=your_api_key\n```\n3. Create an email service in lib/email/index.ts:\n```typescript\nimport { Resend } from 'resend';\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\nconst resend = new Resend(process.env.RESEND_API_KEY);\n\nexport async function sendImmediateNotification(summaryId: string) {\n  const summary = await prisma.summary.findUnique({\n    where: { id: summaryId },\n    include: {\n      ticker: {\n        include: {\n          user: true\n        }\n      }\n    }\n  });\n  \n  if (!summary || summary.sentToUser) {\n    return;\n  }\n  \n  const user = summary.ticker.user;\n  const preferences = user.preferences as any || {};\n  \n  // Check if user wants immediate notifications\n  if (preferences.notifications !== 'immediate') {\n    return;\n  }\n  \n  try {\n    // Format the summary for email\n    const emailContent = formatSummaryForEmail(summary);\n    \n    // Send the email\n    await resend.emails.send({\n      from: 'notifications@tldrsec.com',\n      to: user.email,\n      subject: `New ${summary.filingType} Filing for ${summary.ticker.symbol}`,\n      html: emailContent,\n    });\n    \n    // Mark as sent\n    await prisma.summary.update({\n      where: { id: summaryId },\n      data: { sentToUser: true }\n    });\n  } catch (error) {\n    console.error('Error sending email notification:', error);\n    throw error;\n  }\n}\n\nexport async function sendDailyDigest() {\n  // Get all users who prefer digest emails\n  const users = await prisma.user.findMany({\n    where: {\n      preferences: {\n        path: ['notifications'],\n        equals: 'digest'\n      }\n    },\n    include: {\n      tickers: {\n        include: {\n          summaries: {\n            where: {\n              sentToUser: false,\n              createdAt: {\n                gte: new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n  \n  for (const user of users) {\n    // Collect all unsent summaries for this user\n    const summaries = user.tickers.flatMap(ticker => ticker.summaries);\n    \n    if (summaries.length === 0) {\n      continue;\n    }\n    \n    try {\n      // Format the digest email\n      const emailContent = formatDigestEmail(user, summaries);\n      \n      // Send the email\n      await resend.emails.send({\n        from: 'digest@tldrsec.com',\n        to: user.email,\n        subject: `Your Daily SEC Filings Digest`,\n        html: emailContent,\n      });\n      \n      // Mark all summaries as sent\n      for (const summary of summaries) {\n        await prisma.summary.update({\n          where: { id: summary.id },\n          data: { sentToUser: true }\n        });\n      }\n    } catch (error) {\n      console.error(`Error sending digest to ${user.email}:`, error);\n    }\n  }\n}\n\nfunction formatSummaryForEmail(summary) {\n  // Format the summary as HTML for email\n  let html = `\n    <h1>${summary.ticker.symbol}: ${summary.filingType} Summary</h1>\n    <p><strong>Filing Date:</strong> ${summary.filingDate.toLocaleDateString()}</p>\n    <p><a href=\"${summary.filingUrl}\">View Original Filing</a></p>\n    <hr />\n  `;\n  \n  // If we have structured JSON data\n  if (summary.summaryJSON) {\n    const json = summary.summaryJSON;\n    \n    if (summary.filingType === '10-K' || summary.filingType === '10-Q') {\n      html += `\n        <h2>${json.company} - ${json.period}</h2>\n        <h3>Key Financials</h3>\n        <ul>\n          ${json.financials.map(f => `<li>${f.label}: ${f.value} (${f.growth} ${f.unit})</li>`).join('')}\n        </ul>\n        <h3>Key Insights</h3>\n        <ul>\n          ${json.insights.map(insight => `<li>${insight}</li>`).join('')}\n        </ul>\n        <h3>Risk Factors</h3>\n        <ul>\n          ${json.risks.map(risk => `<li>${risk}</li>`).join('')}\n        </ul>\n      `;\n    } else if (summary.filingType === '8-K') {\n      html += `\n        <h2>${json.company} - ${json.reportDate}</h2>\n        <p><strong>Event Type:</strong> ${json.eventType}</p>\n        <p><strong>Summary:</strong> ${json.summary}</p>\n        <h3>Positive Developments</h3>\n        <p>${json.positiveDevelopments || 'None'}</p>\n        <h3>Potential Concerns</h3>\n        <p>${json.potentialConcerns || 'None'}</p>\n        <h3>Structural Changes</h3>\n        <p>${json.structuralChanges || 'None'}</p>\n      `;\n    } else if (summary.filingType === 'Form4') {\n      html += `\n        <h2>${json.company} - Insider Transaction</h2>\n        <p><strong>Filer:</strong> ${json.filerName} (${json.relationship})</p>\n        <p><strong>Transaction Value:</strong> ${json.totalValue}</p>\n        <p><strong>Change in Ownership:</strong> ${json.percentageChange}</p>\n        <p><strong>New Stake:</strong> ${json.newStake}</p>\n        <p><strong>Summary:</strong> ${json.summary}</p>\n      `;\n    }\n  } else {\n    // Fallback to plain text summary\n    html += `<pre>${summary.summaryText}</pre>`;\n  }\n  \n  html += `\n    <hr />\n    <p><small>You received this email because you're tracking ${summary.ticker.symbol} on tldrSEC. \n    <a href=\"https://tldrsec.com/settings\">Manage your notification preferences</a>.</small></p>\n  `;\n  \n  return html;\n}\n\nfunction formatDigestEmail(user, summaries) {\n  // Group summaries by ticker\n  const byTicker = {};\n  for (const summary of summaries) {\n    const ticker = summary.ticker.symbol;\n    if (!byTicker[ticker]) {\n      byTicker[ticker] = [];\n    }\n    byTicker[ticker].push(summary);\n  }\n  \n  let html = `\n    <h1>Your Daily SEC Filings Digest</h1>\n    <p>Here's a summary of the latest SEC filings for your tracked companies:</p>\n  `;\n  \n  // For each ticker\n  for (const [ticker, tickerSummaries] of Object.entries(byTicker)) {\n    html += `<h2>${ticker}</h2>`;\n    \n    // For each summary for this ticker\n    for (const summary of tickerSummaries) {\n      html += `\n        <div style=\"margin-bottom: 20px; padding: 10px; border: 1px solid #eee;\">\n          <h3>${summary.filingType} - ${summary.filingDate.toLocaleDateString()}</h3>\n          <p><a href=\"${summary.filingUrl}\">View Original Filing</a></p>\n      `;\n      \n      // Add a brief version of the summary\n      if (summary.summaryJSON) {\n        const json = summary.summaryJSON;\n        \n        if (summary.filingType === '10-K' || summary.filingType === '10-Q') {\n          html += `<p><strong>Period:</strong> ${json.period}</p>`;\n          if (json.insights && json.insights.length > 0) {\n            html += `<p><strong>Key Insight:</strong> ${json.insights[0]}</p>`;\n          }\n        } else if (summary.filingType === '8-K') {\n          html += `<p><strong>Event:</strong> ${json.eventType}</p>`;\n          html += `<p>${json.summary}</p>`;\n        } else if (summary.filingType === 'Form4') {\n          html += `<p><strong>Insider:</strong> ${json.filerName}</p>`;\n          html += `<p>${json.summary}</p>`;\n        }\n      } else {\n        // Fallback to a snippet of the text summary\n        const snippet = summary.summaryText.substring(0, 150) + '...';\n        html += `<p>${snippet}</p>`;\n      }\n      \n      html += `\n        <p><a href=\"https://tldrsec.com/summary/${summary.id}\">View Full Summary</a></p>\n        </div>\n      `;\n    }\n  }\n  \n  html += `\n    <hr />\n    <p><small>You received this digest because you're subscribed to daily updates on tldrSEC. \n    <a href=\"https://tldrsec.com/settings\">Manage your notification preferences</a>.</small></p>\n  `;\n  \n  return html;\n}\n```\n4. Create a cron job for sending daily digests in app/api/cron/send-digests/route.ts\n5. Configure the cron job in vercel.json\n6. Add email templates for different notification types\n7. Implement email preference management in user settings",
      "testStrategy": "1. Test email sending functionality with Resend API\n2. Verify email formatting for different filing types\n3. Test immediate notification flow\n4. Test daily digest compilation and sending\n5. Verify user preference handling\n6. Test error handling and retry logic\n7. Verify email tracking and marking summaries as sent",
      "priority": "medium",
      "dependencies": [
        5
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Resend API Integration and Configuration",
          "description": "Set up and configure the Resend API for email delivery, including environment variables, authentication, and basic sending functionality.",
          "dependencies": [],
          "details": "1) Create API keys in Resend dashboard and store securely in environment variables. 2) Implement a wrapper class for Resend API with methods for sending emails and checking delivery status. 3) Set up proper error handling for API failures with retry logic. 4) Create logging for all API interactions. 5) Test with different email configurations to ensure deliverability. 6) Implement unit tests with mocked API responses to verify integration.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Immediate Notification Delivery System",
          "description": "Develop a system to send real-time notifications when new filings are submitted or important updates occur.",
          "dependencies": [
            1
          ],
          "details": "1) Create event listeners for filing submission and update events. 2) Implement a queue system to handle notification bursts and prevent rate limiting. 3) Develop logic to determine notification urgency and recipient list. 4) Add error handling with dead-letter queues for failed deliveries. 5) Implement tracking of sent notifications to prevent duplicates. 6) Test with simulated high-volume events to ensure system stability. 7) Create monitoring for delivery success rates.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Daily Digest Compilation and Scheduling",
          "description": "Create a system to compile daily digests of relevant filings and schedule their delivery at user-preferred times.",
          "dependencies": [
            1
          ],
          "details": "1) Implement a data collection service to aggregate filing activities over 24-hour periods. 2) Create a scheduler using cron jobs to trigger digest compilation at specific times. 3) Develop logic to group and categorize filings by type and relevance. 4) Implement time zone handling for user-specific delivery times. 5) Add retry mechanisms for failed digest deliveries. 6) Test with various user scenarios and time zones. 7) Create monitoring for digest compilation and delivery performance.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Email Template Design for Different Filing Types",
          "description": "Design and implement responsive email templates for various notification types and filing categories.",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "1) Create base email template with consistent branding and layout. 2) Develop specialized templates for immediate notifications vs. digest formats. 3) Implement dynamic content sections for different filing types (legal, financial, administrative). 4) Ensure mobile responsiveness across email clients. 5) Add tracking pixels/links for engagement metrics. 6) Test templates across major email clients (Gmail, Outlook, Apple Mail). 7) Implement a template versioning system for future updates.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "User Preference Management and Subscription Handling",
          "description": "Develop a system for users to manage their notification preferences, including opting in/out of different notification types and frequencies.",
          "dependencies": [
            2,
            3
          ],
          "details": "1) Create database schema for storing user notification preferences. 2) Implement API endpoints for updating notification settings. 3) Develop a user interface for preference management. 4) Add validation to ensure users receive critical notifications. 5) Implement subscription/unsubscription handling with confirmation emails. 6) Create automated tests for preference changes and their effect on notification delivery. 7) Add audit logging for all preference changes for compliance purposes.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 7,
      "title": "Build User Dashboard and Ticker Management",
      "description": "Create the user dashboard with tracked tickers table, search functionality, and ticker management features.",
      "details": "1. Create the dashboard page in app/dashboard/page.tsx:\n```tsx\nimport { auth } from '@clerk/nextjs';\nimport { redirect } from 'next/navigation';\nimport { prisma } from '@/lib/db';\nimport TickerTable from '@/components/TickerTable';\nimport TickerSearch from '@/components/TickerSearch';\nimport DashboardSidebar from '@/components/DashboardSidebar';\n\nexport default async function DashboardPage() {\n  const { userId } = auth();\n  \n  if (!userId) {\n    redirect('/sign-in');\n  }\n  \n  // Fetch user's tickers\n  const tickers = await prisma.ticker.findMany({\n    where: { userId },\n    orderBy: { symbol: 'asc' },\n    include: {\n      summaries: {\n        orderBy: { filingDate: 'desc' },\n        take: 1\n      }\n    }\n  });\n  \n  return (\n    <div className=\"flex min-h-screen\">\n      <DashboardSidebar />\n      \n      <main className=\"flex-1 p-6\">\n        <h1 className=\"text-2xl font-bold mb-6\">Your Dashboard</h1>\n        \n        <div className=\"mb-6\">\n          <TickerSearch userId={userId} />\n        </div>\n        \n        <div className=\"bg-white rounded-lg shadow\">\n          <TickerTable tickers={tickers} />\n        </div>\n      </main>\n    </div>\n  );\n}\n```\n2. Create the TickerTable component in components/TickerTable.tsx:\n```tsx\n'use client';\n\nimport { useState } from 'react';\nimport { \n  Table, \n  TableBody, \n  TableCell, \n  TableHead, \n  TableHeader, \n  TableRow \n} from '@/components/ui/table';\nimport { Button } from '@/components/ui/button';\nimport { formatDistanceToNow } from 'date-fns';\n\nexport default function TickerTable({ tickers }) {\n  const [sortField, setSortField] = useState('symbol');\n  const [sortDirection, setSortDirection] = useState('asc');\n  \n  // Handle sorting\n  const handleSort = (field) => {\n    if (sortField === field) {\n      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');\n    } else {\n      setSortField(field);\n      setSortDirection('asc');\n    }\n  };\n  \n  // Sort tickers\n  const sortedTickers = [...tickers].sort((a, b) => {\n    let aValue = a[sortField];\n    let bValue = b[sortField];\n    \n    // Special case for latest filing date\n    if (sortField === 'latestFiling') {\n      aValue = a.summaries[0]?.filingDate || new Date(0);\n      bValue = b.summaries[0]?.filingDate || new Date(0);\n    }\n    \n    if (aValue < bValue) return sortDirection === 'asc' ? -1 : 1;\n    if (aValue > bValue) return sortDirection === 'asc' ? 1 : -1;\n    return 0;\n  });\n  \n  // Handle ticker removal\n  const removeTicker = async (tickerId) => {\n    if (confirm('Are you sure you want to remove this ticker?')) {\n      try {\n        const response = await fetch(`/api/tickers/${tickerId}`, {\n          method: 'DELETE',\n        });\n        \n        if (response.ok) {\n          // Refresh the page to update the list\n          window.location.reload();\n        } else {\n          alert('Failed to remove ticker');\n        }\n      } catch (error) {\n        console.error('Error removing ticker:', error);\n        alert('An error occurred');\n      }\n    }\n  };\n  \n  return (\n    <Table>\n      <TableHeader>\n        <TableRow>\n          <TableHead \n            className=\"cursor-pointer\"\n            onClick={() => handleSort('symbol')}\n          >\n            Symbol {sortField === 'symbol' && (sortDirection === 'asc' ? '↑' : '↓')}\n          </TableHead>\n          <TableHead \n            className=\"cursor-pointer\"\n            onClick={() => handleSort('companyName')}\n          >\n            Company {sortField === 'companyName' && (sortDirection === 'asc' ? '↑' : '↓')}\n          </TableHead>\n          <TableHead \n            className=\"cursor-pointer\"\n            onClick={() => handleSort('latestFiling')}\n          >\n            Latest Filing {sortField === 'latestFiling' && (sortDirection === 'asc' ? '↑' : '↓')}\n          </TableHead>\n          <TableHead>Actions</TableHead>\n        </TableRow>\n      </TableHeader>\n      <TableBody>\n        {sortedTickers.length === 0 ? (\n          <TableRow>\n            <TableCell colSpan={4} className=\"text-center py-8\">\n              No tickers tracked yet. Add some above!\n            </TableCell>\n          </TableRow>\n        ) : (\n          sortedTickers.map((ticker) => (\n            <TableRow key={ticker.id}>\n              <TableCell className=\"font-medium\">{ticker.symbol}</TableCell>\n              <TableCell>{ticker.companyName}</TableCell>\n              <TableCell>\n                {ticker.summaries[0] ? (\n                  <div>\n                    <div>{ticker.summaries[0].filingType}</div>\n                    <div className=\"text-sm text-gray-500\">\n                      {formatDistanceToNow(new Date(ticker.summaries[0].filingDate), { addSuffix: true })}\n                    </div>\n                  </div>\n                ) : (\n                  <span className=\"text-gray-500\">No filings yet</span>\n                )}\n              </TableCell>\n              <TableCell>\n                <div className=\"flex space-x-2\">\n                  <Button \n                    variant=\"outline\" \n                    size=\"sm\"\n                    onClick={() => window.location.href = `/tickers/${ticker.symbol}`}\n                  >\n                    View\n                  </Button>\n                  <Button \n                    variant=\"destructive\" \n                    size=\"sm\"\n                    onClick={() => removeTicker(ticker.id)}\n                  >\n                    Remove\n                  </Button>\n                </div>\n              </TableCell>\n            </TableRow>\n          ))\n        )}\n      </TableBody>\n    </Table>\n  );\n}\n```\n3. Create the TickerSearch component in components/TickerSearch.tsx\n4. Create the DashboardSidebar component in components/DashboardSidebar.tsx\n5. Implement API routes for ticker management in app/api/tickers/route.ts\n6. Create a ticker detail page in app/tickers/[symbol]/page.tsx\n7. Implement responsive design for mobile and desktop",
      "testStrategy": "1. Test dashboard rendering and data fetching\n2. Verify ticker table sorting functionality\n3. Test ticker search and addition\n4. Verify ticker removal works correctly\n5. Test responsive layout on different screen sizes\n6. Verify navigation between dashboard and ticker details\n7. Test error states and empty states\n8. Verify accessibility of all UI components",
      "priority": "medium",
      "dependencies": [
        1,
        2
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Dashboard Page Layout and Structure",
          "description": "Design and implement the core dashboard layout with header, main content area, and navigation components.",
          "dependencies": [],
          "details": "Create a responsive grid layout with a header containing app logo and user profile, sidebar navigation for different sections, and main content area. Implement state management using React Context or Redux to handle global dashboard state. Design component hierarchy with container/presentational pattern. Include loading states, empty states, and error handling UI components. Create reusable card components for different dashboard widgets.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Ticker Table with Sorting and Filtering",
          "description": "Implement a data table to display user's ticker information with sorting and filtering capabilities.",
          "dependencies": [
            1
          ],
          "details": "Create a table component with columns for ticker symbol, company name, current price, daily change, and actions. Implement client-side sorting for all columns with visual indicators for sort direction. Add filter controls for price range, performance metrics, and sectors. Use virtualization for handling large datasets efficiently. Implement pagination or infinite scrolling. Add visual indicators for positive/negative performance. Include skeleton loaders during data fetching.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Ticker Search and Addition Functionality",
          "description": "Develop search interface and functionality to find and add new tickers to the user's dashboard.",
          "dependencies": [
            1
          ],
          "details": "Create an autocomplete search component with debounced API calls. Implement search results display with company information and key metrics. Design an intuitive 'Add to Dashboard' flow with confirmation. Handle API errors gracefully with user feedback. Add visual feedback for successful additions. Implement local storage caching for recent searches. Create a 'Popular Tickers' suggestion feature. Include tooltips for explaining financial metrics in search results.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Ticker Removal and Management Features",
          "description": "Implement functionality for users to remove, categorize, and manage their tracked tickers.",
          "dependencies": [
            2
          ],
          "details": "Add removal functionality with confirmation dialog to prevent accidental deletions. Implement batch operations for managing multiple tickers simultaneously. Create custom categorization/tagging system for organizing tickers. Design UI for creating watchlists or portfolios. Add drag-and-drop functionality for organizing tickers. Implement undo functionality for accidental removals. Create settings panel for ticker display preferences. Include data persistence through API calls with optimistic UI updates.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Responsive Design Implementation",
          "description": "Ensure the dashboard and all ticker management features work seamlessly across all device sizes.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Implement responsive breakpoints for desktop, tablet, and mobile views. Create alternative layouts for mobile users with collapsible sections. Optimize touch interactions for mobile users. Implement responsive tables that transform to cards on small screens. Create a mobile-specific navigation menu. Test and fix accessibility issues across device sizes. Ensure all interactive elements have appropriate touch targets. Optimize performance for lower-powered mobile devices.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 8,
      "title": "Create User Settings and Preferences",
      "description": "Implement user settings page for managing notification preferences, account settings, and other user-specific configurations.",
      "details": "1. Create the settings page in app/settings/page.tsx:\n```tsx\nimport { auth, currentUser } from '@clerk/nextjs';\nimport { redirect } from 'next/navigation';\nimport { prisma } from '@/lib/db';\nimport SettingsForm from '@/components/SettingsForm';\nimport DashboardSidebar from '@/components/DashboardSidebar';\n\nexport default async function SettingsPage() {\n  const { userId } = auth();\n  const user = await currentUser();\n  \n  if (!userId || !user) {\n    redirect('/sign-in');\n  }\n  \n  // Get user preferences from database\n  const dbUser = await prisma.user.findUnique({\n    where: { id: userId }\n  });\n  \n  // Default preferences\n  const preferences = dbUser?.preferences || {\n    notifications: 'immediate',\n    theme: 'light'\n  };\n  \n  return (\n    <div className=\"flex min-h-screen\">\n      <DashboardSidebar />\n      \n      <main className=\"flex-1 p-6\">\n        <h1 className=\"text-2xl font-bold mb-6\">Settings</h1>\n        \n        <div className=\"bg-white rounded-lg shadow p-6\">\n          <SettingsForm \n            userId={userId} \n            email={user.emailAddresses[0].emailAddress}\n            name={user.firstName + ' ' + user.lastName}\n            preferences={preferences}\n          />\n        </div>\n      </main>\n    </div>\n  );\n}\n```\n2. Create the SettingsForm component in components/SettingsForm.tsx:\n```tsx\n'use client';\n\nimport { useState } from 'react';\nimport { useRouter } from 'next/navigation';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';\nimport { toast } from '@/components/ui/use-toast';\n\nexport default function SettingsForm({ userId, email, name, preferences }) {\n  const router = useRouter();\n  const [isLoading, setIsLoading] = useState(false);\n  const [formData, setFormData] = useState({\n    notifications: preferences.notifications || 'immediate',\n    theme: preferences.theme || 'light'\n  });\n  \n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    setIsLoading(true);\n    \n    try {\n      const response = await fetch('/api/settings', {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          preferences: formData\n        })\n      });\n      \n      if (response.ok) {\n        toast({\n          title: 'Settings updated',\n          description: 'Your preferences have been saved.'\n        });\n        router.refresh();\n      } else {\n        throw new Error('Failed to update settings');\n      }\n    } catch (error) {\n      console.error('Error updating settings:', error);\n      toast({\n        title: 'Error',\n        description: 'Failed to update settings. Please try again.',\n        variant: 'destructive'\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  return (\n    <form onSubmit={handleSubmit} className=\"space-y-6\">\n      <div className=\"space-y-4\">\n        <h2 className=\"text-xl font-semibold\">Account Information</h2>\n        \n        <div className=\"grid grid-cols-1 gap-4 sm:grid-cols-2\">\n          <div className=\"space-y-2\">\n            <Label htmlFor=\"email\">Email</Label>\n            <Input id=\"email\" value={email} disabled />\n            <p className=\"text-sm text-gray-500\">Managed by your authentication provider</p>\n          </div>\n          \n          <div className=\"space-y-2\">\n            <Label htmlFor=\"name\">Name</Label>\n            <Input id=\"name\" value={name} disabled />\n            <p className=\"text-sm text-gray-500\">Managed by your authentication provider</p>\n          </div>\n        </div>\n      </div>\n      \n      <div className=\"space-y-4\">\n        <h2 className=\"text-xl font-semibold\">Notification Preferences</h2>\n        \n        <RadioGroup\n          value={formData.notifications}\n          onValueChange={(value) => setFormData({ ...formData, notifications: value })}\n        >\n          <div className=\"flex items-center space-x-2\">\n            <RadioGroupItem value=\"immediate\" id=\"immediate\" />\n            <Label htmlFor=\"immediate\">Immediate - Send notifications as soon as summaries are ready</Label>\n          </div>\n          <div className=\"flex items-center space-x-2\">\n            <RadioGroupItem value=\"digest\" id=\"digest\" />\n            <Label htmlFor=\"digest\">Daily Digest - Send a daily summary of all new filings</Label>\n          </div>\n          <div className=\"flex items-center space-x-2\">\n            <RadioGroupItem value=\"none\" id=\"none\" />\n            <Label htmlFor=\"none\">None - Don't send email notifications</Label>\n          </div>\n        </RadioGroup>\n      </div>\n      \n      <div className=\"space-y-4\">\n        <h2 className=\"text-xl font-semibold\">Theme Preferences</h2>\n        \n        <RadioGroup\n          value={formData.theme}\n          onValueChange={(value) => setFormData({ ...formData, theme: value })}\n        >\n          <div className=\"flex items-center space-x-2\">\n            <RadioGroupItem value=\"light\" id=\"light\" />\n            <Label htmlFor=\"light\">Light</Label>\n          </div>\n          <div className=\"flex items-center space-x-2\">\n            <RadioGroupItem value=\"dark\" id=\"dark\" />\n            <Label htmlFor=\"dark\">Dark</Label>\n          </div>\n        </RadioGroup>\n      </div>\n      \n      <Button type=\"submit\" disabled={isLoading}>\n        {isLoading ? 'Saving...' : 'Save Settings'}\n      </Button>\n    </form>\n  );\n}\n```\n3. Create the settings API endpoint in app/api/settings/route.ts:\n```typescript\nimport { NextResponse } from 'next/server';\nimport { auth } from '@clerk/nextjs';\nimport { prisma } from '@/lib/db';\n\nexport async function PUT(request) {\n  const { userId } = auth();\n  \n  if (!userId) {\n    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n  }\n  \n  try {\n    const { preferences } = await request.json();\n    \n    // Validate preferences\n    if (!preferences) {\n      return NextResponse.json({ error: 'Invalid request' }, { status: 400 });\n    }\n    \n    // Update user preferences\n    const user = await prisma.user.update({\n      where: { id: userId },\n      data: { preferences }\n    });\n    \n    return NextResponse.json({ success: true, user });\n  } catch (error) {\n    console.error('Error updating settings:', error);\n    return NextResponse.json({ error: 'Failed to update settings' }, { status: 500 });\n  }\n}\n```\n4. Add theme switching functionality\n5. Implement notification preference handling in the email service\n6. Add account deletion functionality\n7. Create a user profile page",
      "testStrategy": "1. Test settings form rendering and initial data loading\n2. Verify preference updates are saved correctly\n3. Test theme switching functionality\n4. Verify notification preferences affect email delivery\n5. Test form validation and error handling\n6. Verify account information display\n7. Test responsive layout on different screen sizes\n8. Verify accessibility of form controls",
      "priority": "low",
      "dependencies": [
        1,
        2,
        6
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Implement Summary Detail Pages",
      "description": "Create detailed summary pages for viewing complete filing summaries with formatting, charts, and links to original filings.",
      "details": "1. Create the summary detail page in app/summary/[id]/page.tsx:\n```tsx\nimport { auth } from '@clerk/nextjs';\nimport { redirect, notFound } from 'next/navigation';\nimport { prisma } from '@/lib/db';\nimport DashboardSidebar from '@/components/DashboardSidebar';\nimport SummaryContent from '@/components/SummaryContent';\nimport { formatDistanceToNow, format } from 'date-fns';\n\nexport default async function SummaryPage({ params }) {\n  const { userId } = auth();\n  \n  if (!userId) {\n    redirect('/sign-in');\n  }\n  \n  const summary = await prisma.summary.findUnique({\n    where: { id: params.id },\n    include: {\n      ticker: true\n    }\n  });\n  \n  if (!summary) {\n    notFound();\n  }\n  \n  // Check if user has access to this summary\n  const userTicker = await prisma.ticker.findFirst({\n    where: {\n      userId,\n      symbol: summary.ticker.symbol\n    }\n  });\n  \n  if (!userTicker) {\n    // User doesn't track this ticker\n    redirect('/dashboard');\n  }\n  \n  return (\n    <div className=\"flex min-h-screen\">\n      <DashboardSidebar />\n      \n      <main className=\"flex-1 p-6\">\n        <div className=\"mb-6\">\n          <h1 className=\"text-2xl font-bold\">\n            {summary.ticker.symbol}: {summary.filingType} Summary\n          </h1>\n          <div className=\"text-gray-500\">\n            Filed {format(new Date(summary.filingDate), 'PPP')} \n            ({formatDistanceToNow(new Date(summary.filingDate), { addSuffix: true })})\n          </div>\n          <div className=\"mt-2\">\n            <a \n              href={summary.filingUrl} \n              target=\"_blank\" \n              rel=\"noopener noreferrer\"\n              className=\"text-blue-600 hover:underline\"\n            >\n              View Original Filing\n            </a>\n          </div>\n        </div>\n        \n        <div className=\"bg-white rounded-lg shadow p-6\">\n          <SummaryContent summary={summary} />\n        </div>\n      </main>\n    </div>\n  );\n}\n```\n2. Create the SummaryContent component in components/SummaryContent.tsx:\n```tsx\n'use client';\n\nimport { useState } from 'react';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\n\nexport default function SummaryContent({ summary }) {\n  const [activeTab, setActiveTab] = useState('formatted');\n  \n  // Parse the JSON summary if available\n  let parsedSummary = null;\n  try {\n    if (summary.summaryJSON) {\n      parsedSummary = typeof summary.summaryJSON === 'string' \n        ? JSON.parse(summary.summaryJSON) \n        : summary.summaryJSON;\n    }\n  } catch (error) {\n    console.error('Error parsing summary JSON:', error);\n  }\n  \n  return (\n    <Tabs defaultValue=\"formatted\" onValueChange={setActiveTab}>\n      <TabsList className=\"mb-4\">\n        <TabsTrigger value=\"formatted\">Formatted</TabsTrigger>\n        <TabsTrigger value=\"raw\">Raw Text</TabsTrigger>\n        {parsedSummary && <TabsTrigger value=\"json\">JSON</TabsTrigger>}\n      </TabsList>\n      \n      <TabsContent value=\"formatted\">\n        {parsedSummary ? (\n          <FormattedSummary \n            summaryData={parsedSummary} \n            filingType={summary.filingType} \n          />\n        ) : (\n          <div className=\"whitespace-pre-wrap\">{summary.summaryText}</div>\n        )}\n      </TabsContent>\n      \n      <TabsContent value=\"raw\">\n        <pre className=\"bg-gray-100 p-4 rounded overflow-auto max-h-[600px]\">\n          {summary.summaryText}\n        </pre>\n      </TabsContent>\n      \n      {parsedSummary && (\n        <TabsContent value=\"json\">\n          <pre className=\"bg-gray-100 p-4 rounded overflow-auto max-h-[600px]\">\n            {JSON.stringify(parsedSummary, null, 2)}\n          </pre>\n        </TabsContent>\n      )}\n    </Tabs>\n  );\n}\n\nfunction FormattedSummary({ summaryData, filingType }) {\n  if (filingType === '10-K' || filingType === '10-Q') {\n    return (\n      <div className=\"space-y-6\">\n        <Card>\n          <CardHeader>\n            <CardTitle>{summaryData.company}</CardTitle>\n            <CardDescription>Period: {summaryData.period}</CardDescription>\n          </CardHeader>\n          <CardContent>\n            <h3 className=\"text-lg font-semibold mb-2\">Key Financials</h3>\n            <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n              {summaryData.financials.map((item, index) => (\n                <div key={index} className=\"bg-gray-50 p-4 rounded\">\n                  <div className=\"text-sm text-gray-500\">{item.label}</div>\n                  <div className=\"text-xl font-bold\">{item.value}</div>\n                  <div className={`text-sm ${item.growth.startsWith('-') ? 'text-red-500' : 'text-green-500'}`}>\n                    {item.growth} {item.unit}\n                  </div>\n                </div>\n              ))}\n            </div>\n            \n            <h3 className=\"text-lg font-semibold mt-6 mb-2\">Key Insights</h3>\n            <ul className=\"list-disc pl-5 space-y-2\">\n              {summaryData.insights.map((insight, index) => (\n                <li key={index}>{insight}</li>\n              ))}\n            </ul>\n            \n            <h3 className=\"text-lg font-semibold mt-6 mb-2\">Risk Factors</h3>\n            <ul className=\"list-disc pl-5 space-y-2\">\n              {summaryData.risks.map((risk, index) => (\n                <li key={index}>{risk}</li>\n              ))}\n            </ul>\n          </CardContent>\n        </Card>\n      </div>\n    );\n  } else if (filingType === '8-K') {\n    return (\n      <div className=\"space-y-6\">\n        <Card>\n          <CardHeader>\n            <CardTitle>{summaryData.company}</CardTitle>\n            <CardDescription>Report Date: {summaryData.reportDate}</CardDescription>\n          </CardHeader>\n          <CardContent>\n            <div className=\"mb-4\">\n              <span className=\"inline-block bg-blue-100 text-blue-800 px-2 py-1 rounded text-sm\">\n                {summaryData.eventType}\n              </span>\n            </div>\n            \n            <h3 className=\"text-lg font-semibold mb-2\">Summary</h3>\n            <p className=\"mb-4\">{summaryData.summary}</p>\n            \n            {summaryData.positiveDevelopments && (\n              <div className=\"mb-4\">\n                <h3 className=\"text-lg font-semibold mb-2\">Positive Developments</h3>\n                <div className=\"bg-green-50 border-l-4 border-green-500 p-4\">\n                  {summaryData.positiveDevelopments}\n                </div>\n              </div>\n            )}\n            \n            {summaryData.potentialConcerns && (\n              <div className=\"mb-4\">\n                <h3 className=\"text-lg font-semibold mb-2\">Potential Concerns</h3>\n                <div className=\"bg-red-50 border-l-4 border-red-500 p-4\">\n                  {summaryData.potentialConcerns}\n                </div>\n              </div>\n            )}\n            \n            {summaryData.structuralChanges && (\n              <div className=\"mb-4\">\n                <h3 className=\"text-lg font-semibold mb-2\">Structural Changes</h3>\n                <div className=\"bg-yellow-50 border-l-4 border-yellow-500 p-4\">\n                  {summaryData.structuralChanges}\n                </div>\n              </div>\n            )}\n            \n            {summaryData.additionalNotes && (\n              <div>\n                <h3 className=\"text-lg font-semibold mb-2\">Additional Notes</h3>\n                <p>{summaryData.additionalNotes}</p>\n              </div>\n            )}\n          </CardContent>\n        </Card>\n      </div>\n    );\n  } else if (filingType === 'Form4') {\n    return (\n      <div className=\"space-y-6\">\n        <Card>\n          <CardHeader>\n            <CardTitle>{summaryData.company}</CardTitle>\n            <CardDescription>Filing Date: {summaryData.filingDate}</CardDescription>\n          </CardHeader>\n          <CardContent>\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4 mb-6\">\n              <div>\n                <h3 className=\"text-sm font-medium text-gray-500\">Insider</h3>\n                <p className=\"text-lg\">{summaryData.filerName}</p>\n                <p className=\"text-sm text-gray-500\">{summaryData.relationship}</p>\n              </div>\n              <div>\n                <h3 className=\"text-sm font-medium text-gray-500\">Ownership Type</h3>\n                <p className=\"text-lg\">{summaryData.ownershipType}</p>\n              </div>\n              <div>\n                <h3 className=\"text-sm font-medium text-gray-500\">Transaction Value</h3>\n                <p className=\"text-lg font-bold\">{summaryData.totalValue}</p>\n              </div>\n              <div>\n                <h3 className=\"text-sm font-medium text-gray-500\">Percentage Change</h3>\n                <p className={`text-lg font-bold ${summaryData.percentageChange.startsWith('-') ? 'text-red-500' : 'text-green-500'}`}>\n                  {summaryData.percentageChange}\n                </p>\n              </div>\n            </div>\n            \n            <div className=\"bg-gray-50 p-4 rounded mb-6\">\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div>\n                  <h3 className=\"text-sm font-medium text-gray-500\">Previous Stake</h3>\n                  <p className=\"text-lg\">{summaryData.previousStake}</p>\n                </div>\n                <div>\n                  <h3 className=\"text-sm font-medium text-gray-500\">New Stake</h3>\n                  <p className=\"text-lg\">{summaryData.newStake}</p>\n                </div>\n              </div>\n            </div>\n            \n            <h3 className=\"text-lg font-semibold mb-2\">Summary</h3>\n            <p>{summaryData.summary}</p>\n          </CardContent>\n        </Card>\n      </div>\n    );\n  }\n  \n  // Fallback for unknown filing types\n  return <div className=\"whitespace-pre-wrap\">{JSON.stringify(summaryData, null, 2)}</div>;\n}\n```\n3. Create an API endpoint to fetch summary details in app/api/summaries/[id]/route.ts\n4. Add navigation links to summaries from the dashboard\n5. Implement charts for financial data visualization using a library like Chart.js or Recharts\n6. Add social sharing functionality\n7. Implement print-friendly view",
      "testStrategy": "1. Test summary page rendering for different filing types\n2. Verify JSON parsing and formatted display\n3. Test tab switching between different views\n4. Verify access control (users can only view summaries for tickers they track)\n5. Test responsive layout on different screen sizes\n6. Verify links to original filings work correctly\n7. Test charts and data visualization\n8. Verify accessibility of all UI components",
      "priority": "medium",
      "dependencies": [
        5,
        7
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Summary Page Layout and Structure",
          "description": "Create the core layout and structure for the summary detail pages with responsive design and consistent UI elements.",
          "dependencies": [],
          "details": "Implement a flexible container layout with header, body, and footer sections. Design a tabbed interface for switching between formatted, raw, and JSON views. Include breadcrumb navigation, page title, metadata section, and action buttons (download, share, etc.). Create responsive breakpoints for mobile, tablet, and desktop views. Design loading states and error handling components. Establish consistent typography, spacing, and color schemes aligned with application design system.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Formatted Summary Display for Different Filing Types",
          "description": "Develop specialized formatting components for each filing type to present data in the most readable and useful manner.",
          "dependencies": [
            1
          ],
          "details": "Create type-specific display components for financial filings, regulatory submissions, and other document types. Implement data visualization components (charts, graphs, tables) for numerical data. Design collapsible sections for lengthy content with appropriate section headers. Format dates, currency values, and percentages according to locale settings. Implement comparison views for historical data where applicable. Create print-friendly CSS for formatted views. Ensure accessibility compliance with proper heading structure, alt text, and ARIA attributes.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Develop Raw and JSON View Implementations",
          "description": "Create technical views to display the underlying raw data and JSON structure of the summary documents.",
          "dependencies": [
            1
          ],
          "details": "Implement syntax highlighting for JSON and raw data views. Create collapsible tree structure for navigating complex JSON objects. Add search functionality within raw and JSON views. Implement copy-to-clipboard functionality for code snippets. Create download options for raw data in various formats (JSON, CSV, XML). Design monospace typography and appropriate color schemes for code display. Add line numbers and proper indentation for improved readability. Ensure performance optimization for large data structures.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement Access Control and Permission Checking",
          "description": "Ensure that summary pages enforce proper access controls and permission checks before displaying sensitive information.",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Integrate with authentication system to verify user identity. Implement permission checks for viewing different types of summaries. Create redacted views for users with partial access permissions. Add audit logging for summary access events. Design informative permission-denied screens with appropriate messaging. Implement row-level security for tabular data where applicable. Create secure download mechanisms that respect user permissions. Test various user roles and permission combinations thoroughly.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Develop Navigation and Linking from Other Parts of the Application",
          "description": "Create a cohesive navigation system that allows users to access summary pages from relevant sections of the application.",
          "dependencies": [
            1,
            4
          ],
          "details": "Implement deep linking to specific summary sections with URL parameters. Create contextual links from dashboard, search results, and related documents. Design preview cards/tooltips for summary links. Implement breadcrumb navigation showing the path to current summary. Add 'recently viewed' tracking for quick access to frequent summaries. Create related content suggestions based on current summary. Ensure consistent URL structure and routing patterns. Implement history state management for back/forward navigation.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 10,
      "title": "Implement Landing Page and Onboarding Flow",
      "description": "Create the landing page, user onboarding flow, and initial ticker selection process for new users.",
      "details": "1. Create the landing page in app/page.tsx:\n```tsx\nimport Link from 'next/link';\nimport { auth } from '@clerk/nextjs';\nimport { Button } from '@/components/ui/button';\nimport { ArrowRight } from 'lucide-react';\n\nexport default async function LandingPage() {\n  const { userId } = auth();\n  \n  return (\n    <div className=\"min-h-screen\">\n      <header className=\"container mx-auto px-4 py-6 flex justify-between items-center\">\n        <div className=\"font-bold text-2xl\">tldrSEC</div>\n        <nav>\n          {userId ? (\n            <Link href=\"/dashboard\">\n              <Button>Dashboard</Button>\n            </Link>\n          ) : (\n            <div className=\"flex gap-4\">\n              <Link href=\"/sign-in\">\n                <Button variant=\"outline\">Sign In</Button>\n              </Link>\n              <Link href=\"/sign-up\">\n                <Button>Sign Up</Button>\n              </Link>\n            </div>\n          )}\n        </nav>\n      </header>\n      \n      <main>\n        <section className=\"py-20 bg-blue-50\">\n          <div className=\"container mx-auto px-4 text-center\">\n            <h1 className=\"text-5xl font-bold mb-6\">Never Miss Critical SEC Filings Again</h1>\n            <p className=\"text-xl mb-8 max-w-3xl mx-auto\">\n              tldrSEC automatically monitors, parses, and summarizes SEC filings for your tracked companies, \n              delivering concise, actionable insights directly to your inbox.\n            </p>\n            <Link href={userId ? \"/dashboard\" : \"/sign-up\"}>\n              <Button size=\"lg\" className=\"gap-2\">\n                {userId ? \"Go to Dashboard\" : \"Get Started\"}\n                <ArrowRight size={16} />\n              </Button>\n            </Link>\n          </div>\n        </section>\n        \n        <section className=\"py-16\">\n          <div className=\"container mx-auto px-4\">\n            <h2 className=\"text-3xl font-bold mb-12 text-center\">How It Works</h2>\n            \n            <div className=\"grid grid-cols-1 md:grid-cols-3 gap-8\">\n              <div className=\"bg-white p-6 rounded-lg shadow-md text-center\">\n                <div className=\"bg-blue-100 text-blue-800 w-12 h-12 rounded-full flex items-center justify-center mx-auto mb-4 text-xl font-bold\">1</div>\n                <h3 className=\"text-xl font-semibold mb-3\">Track Your Companies</h3>\n                <p>Select the companies you want to monitor by adding their ticker symbols to your dashboard.</p>\n              </div>\n              \n              <div className=\"bg-white p-6 rounded-lg shadow-md text-center\">\n                <div className=\"bg-blue-100 text-blue-800 w-12 h-12 rounded-full flex items-center justify-center mx-auto mb-4 text-xl font-bold\">2</div>\n                <h3 className=\"text-xl font-semibold mb-3\">Automatic Monitoring</h3>\n                <p>Our system checks SEC.gov hourly for new filings from your tracked companies.</p>\n              </div>\n              \n              <div className=\"bg-white p-6 rounded-lg shadow-md text-center\">\n                <div className=\"bg-blue-100 text-blue-800 w-12 h-12 rounded-full flex items-center justify-center mx-auto mb-4 text-xl font-bold\">3</div>\n                <h3 className=\"text-xl font-semibold mb-3\">AI-Powered Insights</h3>\n                <p>Receive concise, actionable summaries of complex SEC filings directly to your inbox.</p>\n              </div>\n            </div>\n          </div>\n        </section>\n        \n        <section className=\"py-16 bg-gray-50\">\n          <div className=\"container mx-auto px-4\">\n            <h2 className=\"text-3xl font-bold mb-12 text-center\">Key Features</h2>\n            \n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-8\">\n              <div className=\"flex gap-4\">\n                <div className=\"bg-blue-100 text-blue-800 p-3 h-min rounded-full\">\n                  <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\" strokeLinecap=\"round\" strokeLinejoin=\"round\"><path d=\"M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3\"></path></svg>\n                </div>\n                <div>\n                  <h3 className=\"text-xl font-semibold mb-2\">Automated SEC Filing Monitoring</h3>\n                  <p>Our system checks SEC.gov hourly for new filings and identifies those matching your tracked tickers.</p>\n                </div>\n              </div>\n              \n              <div className=\"flex gap-4\">\n                <div className=\"bg-blue-100 text-blue-800 p-3 h-min rounded-full\">\n                  <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\" strokeLinecap=\"round\" strokeLinejoin=\"round\"><circle cx=\"12\" cy=\"12\" r=\"10\"></circle><path d=\"M12 16v-4\"></path><path d=\"M12 8h.01\"></path></svg>\n                </div>\n                <div>\n                  <h3 className=\"text-xl font-semibold mb-2\">AI-Powered Summarization</h3>\n                  <p>Our AI transforms lengthy, complex documents into actionable insights you can understand at a glance.</p>\n                </div>\n              </div>\n              \n              <div className=\"flex gap-4\">\n                <div className=\"bg-blue-100 text-blue-800 p-3 h-min rounded-full\">\n                  <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\" strokeLinecap=\"round\" strokeLinejoin=\"round\"><path d=\"M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z\"></path><polyline points=\"22,6 12,13 2,6\"></polyline></svg>\n                </div>\n                <div>\n                  <h3 className=\"text-xl font-semibold mb-2\">Email Notification System</h3>\n                  <p>Receive summaries immediately or as a daily digest, based on your preferences.</p>\n                </div>\n              </div>\n              \n              <div className=\"flex gap-4\">\n                <div className=\"bg-blue-100 text-blue-800 p-3 h-min rounded-full\">\n                  <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\" strokeLinecap=\"round\" strokeLinejoin=\"round\"><rect x=\"3\" y=\"3\" width=\"18\" height=\"18\" rx=\"2\" ry=\"2\"></rect><line x1=\"3\" y1=\"9\" x2=\"21\" y2=\"9\"></line><line x1=\"9\" y1=\"21\" x2=\"9\" y2=\"9\"></line></svg>\n                </div>\n                <div>\n                  <h3 className=\"text-xl font-semibold mb-2\">User Dashboard</h3>\n                  <p>Manage your tracked tickers and access historical summaries in one convenient location.</p>\n                </div>\n              </div>\n            </div>\n          </div>\n        </section>\n        \n        <section className=\"py-20 bg-blue-600 text-white\">\n          <div className=\"container mx-auto px-4 text-center\">\n            <h2 className=\"text-3xl font-bold mb-6\">Ready to Get Started?</h2>\n            <p className=\"text-xl mb-8 max-w-2xl mx-auto\">\n              Join today and never miss another important SEC filing. Setup takes less than 2 minutes.\n            </p>\n            <Link href={userId ? \"/dashboard\" : \"/sign-up\"}>\n              <Button size=\"lg\" variant=\"secondary\" className=\"gap-2\">\n                {userId ? \"Go to Dashboard\" : \"Sign Up Now\"}\n                <ArrowRight size={16} />\n              </Button>\n            </Link>\n          </div>\n        </section>\n      </main>\n      \n      <footer className=\"bg-gray-100 py-8\">\n        <div className=\"container mx-auto px-4\">\n          <div className=\"flex flex-col md:flex-row justify-between items-center\">\n            <div className=\"mb-4 md:mb-0\">\n              <div className=\"font-bold text-xl\">tldrSEC</div>\n              <p className=\"text-gray-600\">© {new Date().getFullYear()} tldrSEC. All rights reserved.</p>\n            </div>\n            <div className=\"flex gap-6\">\n              <Link href=\"/privacy\" className=\"text-gray-600 hover:text-gray-900\">Privacy Policy</Link>\n              <Link href=\"/terms\" className=\"text-gray-600 hover:text-gray-900\">Terms of Service</Link>\n              <Link href=\"/contact\" className=\"text-gray-600 hover:text-gray-900\">Contact</Link>\n            </div>\n          </div>\n        </div>\n      </footer>\n    </div>\n  );\n}\n```\n2. Create the onboarding flow in app/onboarding/page.tsx:\n```tsx\nimport { auth, currentUser } from '@clerk/nextjs';\nimport { redirect } from 'next/navigation';\nimport { prisma } from '@/lib/db';\nimport OnboardingForm from '@/components/OnboardingForm';\n\nexport default async function OnboardingPage() {\n  const { userId } = auth();\n  const user = await currentUser();\n  \n  if (!userId || !user) {\n    redirect('/sign-in');\n  }\n  \n  // Check if user has already completed onboarding\n  const dbUser = await prisma.user.findUnique({\n    where: { id: userId },\n    include: { tickers: true }\n  });\n  \n  // If user has tickers, they've completed onboarding\n  if (dbUser?.tickers.length > 0) {\n    redirect('/dashboard');\n  }\n  \n  return (\n    <div className=\"min-h-screen bg-gray-50 flex flex-col justify-center py-12 sm:px-6 lg:px-8\">\n      <div className=\"sm:mx-auto sm:w-full sm:max-w-md\">\n        <h1 className=\"text-center text-3xl font-bold\">Welcome to tldrSEC</h1>\n        <p className=\"mt-2 text-center text-gray-600\">\n          Let's set up your account by adding some companies to track.\n        </p>\n      </div>\n      \n      <div className=\"mt-8 sm:mx-auto sm:w-full sm:max-w-md\">\n        <div className=\"bg-white py-8 px-4 shadow sm:rounded-lg sm:px-10\">\n          <OnboardingForm userId={userId} userEmail={user.emailAddresses[0].emailAddress} />\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n3. Create the OnboardingForm component in components/OnboardingForm.tsx\n4. Create a middleware to redirect new users to onboarding\n5. Implement ticker search and selection during onboarding\n6. Add welcome email functionality\n7. Create a post-onboarding success page",
      "testStrategy": "1. Test landing page rendering and responsiveness\n2. Verify authentication flows from landing page\n3. Test onboarding flow for new users\n4. Verify ticker search and selection during onboarding\n5. Test welcome email delivery\n6. Verify redirects based on user state (new vs. existing)\n7. Test responsive layout on different screen sizes\n8. Verify accessibility of all UI components",
      "priority": "medium",
      "dependencies": [
        1,
        2,
        7
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Landing Page Design and Content Implementation",
          "description": "Create a responsive landing page with compelling content, clear value proposition, and call-to-action elements.",
          "dependencies": [],
          "details": "Design components: Hero section with headline and signup CTA, feature highlights, testimonials, FAQ section, and footer. Implement responsive layouts for mobile, tablet, and desktop. Create copy that clearly communicates product benefits. Add analytics tracking for conversion metrics. Test approaches: A/B testing for CTA placement and messaging, cross-browser compatibility testing, and performance optimization for Core Web Vitals.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Authentication Integration and User State Handling",
          "description": "Implement secure authentication flows and maintain user state across the application.",
          "dependencies": [
            1
          ],
          "details": "Integrate authentication provider (OAuth/JWT). Create login/signup forms with validation. Implement session management and secure cookie handling. Design user state context provider to track authentication status. Create protected routes for authenticated users. Test approaches: Security testing for authentication vulnerabilities, session timeout handling, error state management for failed logins, and unit tests for auth hooks and components.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Onboarding Form and Ticker Selection Implementation",
          "description": "Build multi-step onboarding form with ticker search, selection, and preference settings.",
          "dependencies": [
            2
          ],
          "details": "Design components: Progress indicator, form steps with validation, ticker search with autocomplete, selection interface with add/remove functionality, and preference toggles. Implement form state management with proper validation. Create ticker search API integration. Test approaches: Form validation testing, API response handling, accessibility testing for form elements, and user flow testing for completion rates.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Welcome Email and Success Page Development",
          "description": "Create confirmation email template and success page to confirm completed onboarding.",
          "dependencies": [
            3
          ],
          "details": "Design responsive email template with branding and next steps. Implement email sending service integration. Create success page with confirmation message and guidance on next actions. Add confetti animation or visual feedback for completion. Test approaches: Email rendering tests across email clients, deliverability testing, success page responsive design testing, and tracking for email open rates.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Middleware for New User Redirection",
          "description": "Implement middleware logic to detect new users and redirect to appropriate onboarding steps.",
          "dependencies": [
            2,
            3
          ],
          "details": "Create middleware to check user completion status. Implement redirection logic based on onboarding progress. Add persistence for partially completed onboarding. Design skip/resume functionality for returning users. Test approaches: User journey testing with various account states, redirect loop prevention testing, and performance testing for middleware execution time.",
          "status": "pending"
        }
      ]
    }
  ]
}